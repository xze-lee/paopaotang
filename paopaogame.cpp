#include<conio.h>
#include<iostream>
#include<utility>
#include<map>
#include<cstdlib>
#include<ctime>
using namespace std;

class map_g {
private:
    //初始化整张地图
    char m[15][17] = { {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                       {'#','*','#',' ','#','*',' ','*',' ','*',' ','*','#',' ',' ','*','#'},
                       {'#',' ','*','*','*','*','*','#',' ','#',' ','*',' ',' ',' ','#','#'},
                       {'#',' ','#','#',' ','#','*','#','*',' ','*','#',' ','#','*',' ','#'},
                       {'#',' ','*',' ',' ',' ','*','#','*','#','*',' ',' ',' ',' ','#','#'},
                       {'#',' ','#','#',' ','#',' ','*','*',' ','#','#',' ','#','*','*','#'},
                       {'#','*','*','#',' ','#',' ','#','#','*','*','*','*','*','*',' ','#'},
                       {'#',' ','#',' ','#','*','#','#','#','*','#','#',' ','#','#','*','#'},
                       {'#',' ',' ',' ','*','*','*','*','*','*','*','#','*','*','*',' ','#'},
                       {'#',' ','#','#',' ','#','#','*','#','#',' ','#',' ','#','#','*','#'},
                       {'#','*',' ',' ',' ',' ',' ','*',' ','#',' ',' ',' ',' ','*',' ','#'},
                       {'#','*','#','#',' ','#','#','*','*','*','*','#',' ','#','#','*','#'},
                       {'#','*','*','#',' ',' ','*','*','#','#',' ','*',' ','*','#','*','#'},
                       {'#','*',' ',' ','*','*','#',' ','*','*',' ','#',' ','*',' ','*','#'},
                       {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'}
    };
public:
    char get_obj(int x, int y) {
        return m[x][y];
       
    }
    void change_map(int x,int y,char c) {
        m[x][y] = c;
        return;
    }
    void type_map() {
        for (int i = 0; i < 15; i++) {            puts(m[i]);        }
    };
    // 在这里随机产生一个道具
    void items(int x, int y) {
        unsigned seed;
        seed = time(0);
        srand(seed);
        int num = rand() % 5;
        if (num == 0) m[x][y] = 's';
        else if (num == 1) m[x][y] = 'p';
        else m[x][y] = ' ';
    }
};
//定义全局类对象game_map
map_g game_map;
//记录每个人的炸弹的信息,每个人的炸弹打中了几个人。class bomb {private:    pair<int, int>location;    char symbol = 'o';    int power=1; //这个炸弹的威力    bool ifbomb = false;    int kills = 0;    char belong;public:    //放炸弹    void putbomb(int x,int y) {        if (ifbomb) return;        game_map.change_map(x, y, symbol);        location.first = x;        location.second = y;        //一段统一打印地图和分数的代码        game_map.type_map();        cout << "Player1: " << p1.get_point() << "kills" << "  state: " << p1.get_state();        cout << "Player2: " << p2.get_point() << "kills" << "  state: " << p2.get_state();        cout << "Computer1: " << c1.get_point() << "kills" << "  state: " << c1.get_state();        cout << "Computer2: " << c2.get_point() << "kills" << "  state: " << c2.get_state();        ifbomb = true;    }    //炸弹爆炸，出现炸弹光波'x'    void finish() {        ifbomb = false;        bool stop = false;        game_map.change_map(location.first, location.second, 'x');        //向上炸        for (int i = 1; i <= power; i++) {            if (stop) break;            switch (game_map.get_obj(location.first-i, location.second)) {            case ' ':game_map.change_map(location.first - i, location.second, 'x'); break;            case '*':stop = true; game_map.items(location.first - i, location.second); break;            case '#':stop = true; break;            //如果炸到玩家，玩家的状态变为die，如果炸到的不是自己，那么得分加一，地图上光波继续            case '1':if (belong != '1') kills++; p1.die(); game_map.change_map(location.first - i, location.second, 'x'); break;            case '2':if (belong != '2') kills++; p2.die(); game_map.change_map(location.first - i, location.second, 'x'); break;            case '3':if (belong != '3') kills++; c1.die(); game_map.change_map(location.first - i, location.second, 'x'); break;            case '4':if (belong != '4') kills++; c1.die(); game_map.change_map(location.first - i, location.second, 'x'); break;            }        }        //向下炸        for (int i = 1; i <= power; i++) {            if (stop) break;            switch (game_map.get_obj(location.first + i, location.second)) {            case ' ':game_map.change_map(location.first + i, location.second, 'x'); break;            case '*': stop = true; game_map.items(location.first + i, location.second); break;            case '#':stop = true; break;                //如果炸到玩家，玩家的状态变为die，如果炸到的不是自己，那么得分加一，地图上光波继续            case '1':if (belong != '1') kills++; p1.die(); game_map.change_map(location.first + i, location.second, 'x'); break;            case '2':if (belong != '2') kills++; p2.die(); game_map.change_map(location.first + i, location.second, 'x'); break;            case '3':if (belong != '3') kills++; c1.die(); game_map.change_map(location.first + i, location.second, 'x'); break;            case '4':if (belong != '4') kills++; c1.die(); game_map.change_map(location.first + i, location.second, 'x'); break;            }        }        //向左炸        for (int i = 1; i <= power; i++) {            if (stop) break;            switch (game_map.get_obj(location.first, location.second - i)) {            case ' ':game_map.change_map(location.first, location.second - i, 'x'); break;                //炸到软墙，出道具，光波停止            case '*': stop = true; game_map.items(location.first, location.second - i); break;            case '#':stop = true; break;                //如果炸到玩家，玩家的状态变为die，如果炸到的不是自己，那么得分加一，地图上光波继续            case '1':if (belong != '1') kills++; p1.die(); game_map.change_map(location.first, location.second - i, 'x'); break;            case '2':if (belong != '2') kills++; p2.die(); game_map.change_map(location.first, location.second - i, 'x'); break;            case '3':if (belong != '3') kills++; c1.die(); game_map.change_map(location.first, location.second - i, 'x'); break;            case '4':if (belong != '4') kills++; c1.die(); game_map.change_map(location.first, location.second - i, 'x'); break;            }        }        //向右炸        for (int i = 1; i <= power; i++) {            if (stop) break;            switch (game_map.get_obj(location.first, location.second + i)) {            case ' ':game_map.change_map(location.first, location.second + i, 'x'); break;                //炸到软墙，出道具，光波停止            case '*': stop = true; game_map.items(location.first, location.second + i); break;            case '#':stop = true; break;                //如果炸到玩家，玩家的状态变为die，如果炸到的不是自己，那么得分加一，地图上光波继续            case '1':if (belong != '1') kills++; p1.die(); game_map.change_map(location.first, location.second + i, 'x'); break;            case '2':if (belong != '2') kills++; p2.die(); game_map.change_map(location.first, location.second + i, 'x'); break;            case '3':if (belong != '3') kills++; c1.die(); game_map.change_map(location.first, location.second + i, 'x'); break;            case '4':if (belong != '4') kills++; c1.die(); game_map.change_map(location.first, location.second + i, 'x'); break;            }        }        //一段统一打印地图和分数的代码        game_map.type_map();        cout << "Player1: " << p1.get_point() << "kills" << "  state: " << p1.get_state();        cout << "Player2: " << p2.get_point() << "kills" << "  state: " << p2.get_state();        cout << "Computer1: " << c1.get_point() << "kills" << "  state: " << c1.get_state();        cout << "Computer2: " << c2.get_point() << "kills" << "  state: " << c2.get_state();    }    void renew_power() {        power++;    }    void get_belong(char x) {        belong = x;    }    int get_kills() {        return kills;    }};class player {private:    pair<int, int> location;    char symbol;  //玩家的符号 分别为'1'  '2'  '3'  '4'    char state = 'l';    bomb b;  //每个玩家拥有自己的炸弹类public:    player(int x, int y, char symbol) {        location.first = x;        location.second = y;        this->symbol = symbol;        b.get_belong(symbol);    }    // wsad ikjl    // 更新人物的位置并在图中显示出来    void update_location(int type,map_point &m) {        int &f = location.first; int &s = location.second;        switch (type) {        case 'w':if (m.get_obj(f, s, 'w') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             f++;             m.change_map(f, s, symbol); break;        }                else break;        case 'i':if (m.get_obj(f, s, 'w') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             f++;             m.change_map(f, s, symbol); break;        }                else break;        case 's':if (m.get_obj(f, s, 's') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             f--;             m.change_map(f, s, symbol); break;        }                else break;        case 'k':if (m.get_obj(f, s, 's') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             f--;             m.change_map(f, s, symbol); break;        }                else break;        case 'a':if (m.get_obj(f, s, 'a') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             s--;             m.change_map(f, s, symbol); break;        }                else break;        case 'j':if (m.get_obj(f, s, 'a') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             s--;             m.change_map(f, s, symbol); break;        }                else break;        case 'd':if (m.get_obj(f, s, 'd') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                 m.change_map(f, s, ' ');             s++;             m.change_map(f, s, symbol); break;        }                else break;        case 'l':if (m.get_obj(f, s, 'd') == ' ') {            if (m.get_obj(f, s, ' ') != 'o')                m.change_map(f, s, ' ');            s++;            m.change_map(f, s, symbol); break;        }                else break;        }    }    //获得人的位置    pair<int, int>get_location() {        return(location);    }    //获得人的状态，死，活    void die() {        state = 'd';    }    char get_state() {        return state;    }    int get_point() {        return b.get_kills();    }};player p1(3,3,'1'); player p2(3,13,'2'); player c1(13,3,'3'); player c2(13,13,'4');int main() {}